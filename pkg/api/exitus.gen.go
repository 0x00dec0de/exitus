// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Comment defines model for Comment.
type Comment struct {
	Author    User      `json:"author"`
	Content   string    `json:"content"`
	CreatedAt time.Time `json:"created_at"`
	Id        string    `json:"id"`
	UpdatedAt time.Time `json:"updated_at"`
}

// CommentsPage defines model for CommentsPage.
type CommentsPage struct {
	Comments []Comment `json:"comments"`
}

// Customer defines model for Customer.
type Customer struct {
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          string    `json:"id"`
	Labels      []string  `json:"labels"`
	Name        string    `json:"name"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// CustomersPage defines model for CustomersPage.
type CustomersPage struct {
	Customers []Customer `json:"customers"`
}

// Issue defines model for Issue.
type Issue struct {
	Assignee  *User         `json:"assignee,omitempty"`
	Category  string        `json:"category"`
	Comments  *CommentsPage `json:"comments,omitempty"`
	Content   *string       `json:"content,omitempty"`
	CreatedAt time.Time     `json:"created_at"`
	Id        string        `json:"id"`
	Labels    []string      `json:"labels"`
	Reporter  *User         `json:"reporter,omitempty"`
	Severity  string        `json:"severity"`
	State     string        `json:"state"`
	Subject   string        `json:"subject"`
	UpdatedAt time.Time     `json:"updated_at"`
}

// IssuesPage defines model for IssuesPage.
type IssuesPage struct {
	Issues []Issue `json:"issues"`
}

// NewComment defines model for NewComment.
type NewComment struct {
	Content string `json:"content"`
}

// NewCustomer defines model for NewCustomer.
type NewCustomer struct {
	Description *string  `json:"description,omitempty"`
	Labels      []string `json:"labels"`
	Name        string   `json:"name"`
}

// NewIssue defines model for NewIssue.
type NewIssue struct {
	Category string   `json:"category"`
	Content  string   `json:"content"`
	Labels   []string `json:"labels"`
	Severity string   `json:"severity"`
	Subject  string   `json:"subject"`
}

// NewProject defines model for NewProject.
type NewProject struct {
	Description *string  `json:"description,omitempty"`
	Labels      []string `json:"labels"`
	Name        string   `json:"name"`
}

// Project defines model for Project.
type Project struct {
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          string    `json:"id"`
	Labels      []string  `json:"labels"`
	Name        string    `json:"name"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// ProjectsPage defines model for ProjectsPage.
type ProjectsPage struct {
	Projects []Project `json:"projects"`
}

// UpdatedComment defines model for UpdatedComment.
type UpdatedComment struct {
	// Embedded struct due to allOf(#/components/schemas/NewComment)
	NewComment
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// UpdatedCustomer defines model for UpdatedCustomer.
type UpdatedCustomer struct {
	// Embedded struct due to allOf(#/components/schemas/NewCustomer)
	NewCustomer
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// UpdatedIssue defines model for UpdatedIssue.
type UpdatedIssue struct {
	// Embedded struct due to allOf(#/components/schemas/NewIssue)
	NewIssue
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// UpdatedProject defines model for UpdatedProject.
type UpdatedProject struct {
	// Embedded struct due to allOf(#/components/schemas/NewProject)
	NewProject
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// User defines model for User.
type User struct {
	CreatedAt time.Time `json:"created_at"`
	Email     string    `json:"email"`
	Id        string    `json:"id"`
	Name      string    `json:"name"`
	UpdatedAt time.Time `json:"updated_at"`
}

// UsersPage defines model for UsersPage.
type UsersPage struct {
	Users []User `json:"users"`
}

// FilterIssues defines model for filterIssues.
type FilterIssues []string

// Limit defines model for limit.
type Limit int64

// Offset defines model for offset.
type Offset int64

// Q defines model for q.
type Q string

// CustomersParams defines parameters for Customers.
type CustomersParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// ProjectsParams defines parameters for Projects.
type ProjectsParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// IssuesParams defines parameters for Issues.
type IssuesParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// CommentsParams defines parameters for Comments.
type CommentsParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// UsersParams defines parameters for Users.
type UsersParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// NewCustomerRequestBody defines body for NewCustomer for application/json ContentType.
type NewCustomerJSONRequestBody NewCustomer

// UpdateCustomerRequestBody defines body for UpdateCustomer for application/json ContentType.
type UpdateCustomerJSONRequestBody UpdatedCustomer

// NewProjectRequestBody defines body for NewProject for application/json ContentType.
type NewProjectJSONRequestBody NewProject

// UpdateProjectRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody UpdatedProject

// NewIssueRequestBody defines body for NewIssue for application/json ContentType.
type NewIssueJSONRequestBody NewIssue

// NewCommentRequestBody defines body for NewComment for application/json ContentType.
type NewCommentJSONRequestBody NewComment

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get a list of customers.// (GET /customers)
	Customers(ctx echo.Context, params CustomersParams) error
	// Create a customer.// (POST /customers)
	NewCustomer(ctx echo.Context) error
	// (GET /customers/{id})
	GetCustomer(ctx echo.Context, id string) error
	// Update a customer.// (PUT /customers/{id})
	UpdateCustomer(ctx echo.Context, id string) error
	// Get a list of projects.// (GET /projects)
	Projects(ctx echo.Context, params ProjectsParams) error
	// Create a project.// (POST /projects)
	NewProject(ctx echo.Context) error
	// (GET /projects/{id})
	GetProject(ctx echo.Context, id string) error
	// Update a project.// (PUT /projects/{id})
	UpdateProject(ctx echo.Context, id string) error
	// Get a list of issues.// (GET /projects/{project_id}/issues)
	Issues(ctx echo.Context, projectId string, params IssuesParams) error
	// Create a issue.// (POST /projects/{project_id}/issues)
	NewIssue(ctx echo.Context, projectId string) error
	// (GET /projects/{project_id}/issues/{id})
	GetIssue(ctx echo.Context, projectId string, id string) error
	// (PUT /projects/{project_id}/issues/{id})
	UpdateIssue(ctx echo.Context, projectId string, id string) error
	// Get a list of Comments.// (GET /projects/{project_id}/issues/{issue_id}/comments)
	Comments(ctx echo.Context, projectId string, issueId string, params CommentsParams) error
	// Create a comment on a issue.// (POST /projects/{project_id}/issues/{issue_id}/comments)
	NewComment(ctx echo.Context, projectId string, issueId string) error
	// (PUT /projects/{project_id}/issues/{issue_id}/comments/{id})
	UpdateComment(ctx echo.Context, projectId string, issueId string, id string) error
	// Get a list of users.// (GET /users)
	Users(ctx echo.Context, params UsersParams) error
	// (GET /users/{id})
	GetUser(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Customers converts echo context to params.
func (w *ServerInterfaceWrapper) Customers(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Customers(ctx, params)
	return err
}

// NewCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) NewCustomer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewCustomer(ctx)
	return err
}

// GetCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomer(ctx, id)
	return err
}

// UpdateCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCustomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateCustomer(ctx, id)
	return err
}

// Projects converts echo context to params.
func (w *ServerInterfaceWrapper) Projects(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ProjectsParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Projects(ctx, params)
	return err
}

// NewProject converts echo context to params.
func (w *ServerInterfaceWrapper) NewProject(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewProject(ctx)
	return err
}

// GetProject converts echo context to params.
func (w *ServerInterfaceWrapper) GetProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProject(ctx, id)
	return err
}

// UpdateProject converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateProject(ctx, id)
	return err
}

// Issues converts echo context to params.
func (w *ServerInterfaceWrapper) Issues(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params IssuesParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Issues(ctx, projectId, params)
	return err
}

// NewIssue converts echo context to params.
func (w *ServerInterfaceWrapper) NewIssue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewIssue(ctx, projectId)
	return err
}

// GetIssue converts echo context to params.
func (w *ServerInterfaceWrapper) GetIssue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetIssue(ctx, projectId, id)
	return err
}

// UpdateIssue converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateIssue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateIssue(ctx, projectId, id)
	return err
}

// Comments converts echo context to params.
func (w *ServerInterfaceWrapper) Comments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameter("simple", false, "issue_id", ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params CommentsParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Comments(ctx, projectId, issueId, params)
	return err
}

// NewComment converts echo context to params.
func (w *ServerInterfaceWrapper) NewComment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameter("simple", false, "issue_id", ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewComment(ctx, projectId, issueId)
	return err
}

// UpdateComment converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateComment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameter("simple", false, "issue_id", ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateComment(ctx, projectId, issueId, id)
	return err
}

// Users converts echo context to params.
func (w *ServerInterfaceWrapper) Users(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UsersParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Users(ctx, params)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUser(ctx, id)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {
	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/customers", wrapper.Customers)
	router.POST("/customers", wrapper.NewCustomer)
	router.GET("/customers/:id", wrapper.GetCustomer)
	router.PUT("/customers/:id", wrapper.UpdateCustomer)
	router.GET("/projects", wrapper.Projects)
	router.POST("/projects", wrapper.NewProject)
	router.GET("/projects/:id", wrapper.GetProject)
	router.PUT("/projects/:id", wrapper.UpdateProject)
	router.GET("/projects/:project_id/issues", wrapper.Issues)
	router.POST("/projects/:project_id/issues", wrapper.NewIssue)
	router.GET("/projects/:project_id/issues/:id", wrapper.GetIssue)
	router.PUT("/projects/:project_id/issues/:id", wrapper.UpdateIssue)
	router.GET("/projects/:project_id/issues/:issue_id/comments", wrapper.Comments)
	router.POST("/projects/:project_id/issues/:issue_id/comments", wrapper.NewComment)
	router.PUT("/projects/:project_id/issues/:issue_id/comments/:id", wrapper.UpdateComment)
	router.GET("/users", wrapper.Users)
	router.GET("/users/:id", wrapper.GetUser)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"TT0AAA==",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
