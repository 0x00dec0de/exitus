// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Comment defines model for Comment.
type Comment struct {
	Author    User      `json:"author"`
	Content   string    `json:"content"`
	CreatedAt time.Time `json:"created_at"`
	Id        string    `json:"id"`
	UpdatedAt time.Time `json:"updated_at"`
}

// CommentsPage defines model for CommentsPage.
type CommentsPage struct {
	Comments []Comment `json:"comments"`
}

// Customer defines model for Customer.
type Customer struct {
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          string    `json:"id"`
	Labels      []string  `json:"labels"`
	Name        string    `json:"name"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// CustomersPage defines model for CustomersPage.
type CustomersPage struct {
	Customers []Customer `json:"customers"`
}

// Issue defines model for Issue.
type Issue struct {
	Assignee  *User         `json:"assignee,omitempty"`
	Author    User          `json:"author"`
	Category  *string       `json:"category,omitempty"`
	Comments  *CommentsPage `json:"comments,omitempty"`
	Content   *string       `json:"content,omitempty"`
	CreatedAt time.Time     `json:"created_at"`
	Id        string        `json:"id"`
	Labels    *[]string     `json:"labels,omitempty"`
	Severity  *string       `json:"severity,omitempty"`
	Subject   string        `json:"subject"`
	UpdatedAt time.Time     `json:"updated_at"`
}

// IssuesPage defines model for IssuesPage.
type IssuesPage struct {
	Issues []Issue `json:"issues"`
}

// NewComment defines model for NewComment.
type NewComment struct {
	Content string `json:"content"`
}

// NewCustomer defines model for NewCustomer.
type NewCustomer struct {
	Description *string  `json:"description,omitempty"`
	Labels      []string `json:"labels"`
	Name        string   `json:"name"`
}

// NewIssue defines model for NewIssue.
type NewIssue struct {
	Content *string   `json:"content,omitempty"`
	Labels  *[]string `json:"labels,omitempty"`
	Subject string    `json:"subject"`
}

// NewProject defines model for NewProject.
type NewProject struct {
	Description *string  `json:"description,omitempty"`
	Labels      []string `json:"labels"`
	Name        string   `json:"name"`
}

// Project defines model for Project.
type Project struct {
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          string    `json:"id"`
	Labels      []string  `json:"labels"`
	Name        string    `json:"name"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// ProjectsPage defines model for ProjectsPage.
type ProjectsPage struct {
	Projects []Project `json:"projects"`
}

// UpdatedCustomer defines model for UpdatedCustomer.
type UpdatedCustomer struct {
	// Embedded struct due to allOf(#/components/schemas/NewCustomer)
	NewCustomer
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// UpdatedProject defines model for UpdatedProject.
type UpdatedProject struct {
	// Embedded struct due to allOf(#/components/schemas/NewProject)
	NewProject
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// User defines model for User.
type User struct {
	CreatedAt time.Time `json:"created_at"`
	Email     string    `json:"email"`
	Id        string    `json:"id"`
	Name      string    `json:"name"`
	UpdatedAt time.Time `json:"updated_at"`
}

// UsersPage defines model for UsersPage.
type UsersPage struct {
	Users []User `json:"users"`
}

// FilterIssues defines model for filterIssues.
type FilterIssues []string

// Limit defines model for limit.
type Limit int64

// Offset defines model for offset.
type Offset int64

// Q defines model for q.
type Q string

// CustomersParams defines parameters for Customers.
type CustomersParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// ProjectsParams defines parameters for Projects.
type ProjectsParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// IssuesParams defines parameters for Issues.
type IssuesParams struct {
	Offset *Offset       `json:"offset,omitempty"`
	Limit  *Limit        `json:"limit,omitempty"`
	Filter *FilterIssues `json:"filter,omitempty"`
}

// CommentsParams defines parameters for Comments.
type CommentsParams struct {
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// UsersParams defines parameters for Users.
type UsersParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// NewCustomerRequestBody defines body for NewCustomer for application/json ContentType.
type NewCustomerJSONRequestBody NewCustomer

// UpdateCustomerRequestBody defines body for UpdateCustomer for application/json ContentType.
type UpdateCustomerJSONRequestBody UpdatedCustomer

// NewProjectRequestBody defines body for NewProject for application/json ContentType.
type NewProjectJSONRequestBody NewProject

// UpdateProjectRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody UpdatedProject

// NewIssueRequestBody defines body for NewIssue for application/json ContentType.
type NewIssueJSONRequestBody NewIssue

// NewCommentRequestBody defines body for NewComment for application/json ContentType.
type NewCommentJSONRequestBody NewComment

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get a list of customers.// (GET /customers)
	Customers(ctx echo.Context, params CustomersParams) error
	// Create a customer.// (POST /customers)
	NewCustomer(ctx echo.Context) error
	// (GET /customers/{id})
	GetCustomer(ctx echo.Context, id string) error
	// Update a customer.// (PUT /customers/{id})
	UpdateCustomer(ctx echo.Context, id string) error
	// Get a list of projects.// (GET /projects)
	Projects(ctx echo.Context, params ProjectsParams) error
	// Create a project.// (POST /projects)
	NewProject(ctx echo.Context) error
	// (GET /projects/{id})
	GetProject(ctx echo.Context, id string) error
	// Update a project.// (PUT /projects/{id})
	UpdateProject(ctx echo.Context, id string) error
	// Get a list of issues.// (GET /projects/{project_id}/issues)
	Issues(ctx echo.Context, projectId string, params IssuesParams) error
	// Create a issue.// (POST /projects/{project_id}/issues)
	NewIssue(ctx echo.Context, projectId string) error
	// (GET /projects/{project_id}/issues/{id})
	GetIssue(ctx echo.Context, projectId string, id string) error
	// Get a list of Comments.// (GET /projects/{project_id}/issues/{issue_id}/comments)
	Comments(ctx echo.Context, projectId string, issueId string, params CommentsParams) error
	// Create a comment on a issue.// (POST /projects/{project_id}/issues/{issue_id}/comments)
	NewComment(ctx echo.Context, projectId string, issueId string) error
	// (GET /projects/{project_id}/issues/{issue_id}/comments/{id})
	GetComment(ctx echo.Context, projectId string, issueId string, id string) error
	// Get a list of users.// (GET /users)
	Users(ctx echo.Context, params UsersParams) error
	// (GET /users/{id})
	GetUser(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Customers converts echo context to params.
func (w *ServerInterfaceWrapper) Customers(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Customers(ctx, params)
	return err
}

// NewCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) NewCustomer(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewCustomer(ctx)
	return err
}

// GetCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomer(ctx, id)
	return err
}

// UpdateCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCustomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateCustomer(ctx, id)
	return err
}

// Projects converts echo context to params.
func (w *ServerInterfaceWrapper) Projects(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ProjectsParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Projects(ctx, params)
	return err
}

// NewProject converts echo context to params.
func (w *ServerInterfaceWrapper) NewProject(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewProject(ctx)
	return err
}

// GetProject converts echo context to params.
func (w *ServerInterfaceWrapper) GetProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProject(ctx, id)
	return err
}

// UpdateProject converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateProject(ctx, id)
	return err
}

// Issues converts echo context to params.
func (w *ServerInterfaceWrapper) Issues(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params IssuesParams
	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------
	if paramValue := ctx.QueryParam("filter"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("pipeDelimited", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Issues(ctx, projectId, params)
	return err
}

// NewIssue converts echo context to params.
func (w *ServerInterfaceWrapper) NewIssue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewIssue(ctx, projectId)
	return err
}

// GetIssue converts echo context to params.
func (w *ServerInterfaceWrapper) GetIssue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetIssue(ctx, projectId, id)
	return err
}

// Comments converts echo context to params.
func (w *ServerInterfaceWrapper) Comments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameter("simple", false, "issue_id", ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params CommentsParams
	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Comments(ctx, projectId, issueId, params)
	return err
}

// NewComment converts echo context to params.
func (w *ServerInterfaceWrapper) NewComment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameter("simple", false, "issue_id", ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewComment(ctx, projectId, issueId)
	return err
}

// GetComment converts echo context to params.
func (w *ServerInterfaceWrapper) GetComment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameter("simple", false, "issue_id", ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetComment(ctx, projectId, issueId, id)
	return err
}

// Users converts echo context to params.
func (w *ServerInterfaceWrapper) Users(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UsersParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Users(ctx, params)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUser(ctx, id)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {
	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/customers", wrapper.Customers)
	router.POST("/customers", wrapper.NewCustomer)
	router.GET("/customers/:id", wrapper.GetCustomer)
	router.PUT("/customers/:id", wrapper.UpdateCustomer)
	router.GET("/projects", wrapper.Projects)
	router.POST("/projects", wrapper.NewProject)
	router.GET("/projects/:id", wrapper.GetProject)
	router.PUT("/projects/:id", wrapper.UpdateProject)
	router.GET("/projects/:project_id/issues", wrapper.Issues)
	router.POST("/projects/:project_id/issues", wrapper.NewIssue)
	router.GET("/projects/:project_id/issues/:id", wrapper.GetIssue)
	router.GET("/projects/:project_id/issues/:issue_id/comments", wrapper.Comments)
	router.POST("/projects/:project_id/issues/:issue_id/comments", wrapper.NewComment)
	router.GET("/projects/:project_id/issues/:issue_id/comments/:id", wrapper.GetComment)
	router.GET("/users", wrapper.Users)
	router.GET("/users/:id", wrapper.GetUser)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
