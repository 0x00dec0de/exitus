// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Comment defines model for Comment.
type Comment struct {
	Author    User      `json:"author"`
	Content   string    `json:"content"`
	CreatedAt time.Time `json:"created_at"`
	Id        string    `json:"id"`
	UpdatedAt time.Time `json:"updated_at"`
}

// CommentsPage defines model for CommentsPage.
type CommentsPage struct {
	Comments []Comment `json:"comments"`
}

// Customer defines model for Customer.
type Customer struct {
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          string    `json:"id"`
	Labels      []string  `json:"labels"`
	Name        string    `json:"name"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// CustomersPage defines model for CustomersPage.
type CustomersPage struct {
	Customers []Customer `json:"customers"`
}

// Issue defines model for Issue.
type Issue struct {
	Assignee  *User         `json:"assignee,omitempty"`
	Category  string        `json:"category"`
	Comments  *CommentsPage `json:"comments,omitempty"`
	Content   *string       `json:"content,omitempty"`
	CreatedAt time.Time     `json:"created_at"`
	Id        string        `json:"id"`
	Labels    []string      `json:"labels"`
	Reporter  *User         `json:"reporter,omitempty"`
	Severity  string        `json:"severity"`
	State     string        `json:"state"`
	Subject   string        `json:"subject"`
	UpdatedAt time.Time     `json:"updated_at"`
}

// IssuesPage defines model for IssuesPage.
type IssuesPage struct {
	Issues []Issue `json:"issues"`
}

// NewComment defines model for NewComment.
type NewComment struct {
	Content string `json:"content"`
}

// NewCustomer defines model for NewCustomer.
type NewCustomer struct {
	Description *string  `json:"description,omitempty"`
	Labels      []string `json:"labels"`
	Name        string   `json:"name"`
}

// NewIssue defines model for NewIssue.
type NewIssue struct {
	Category string   `json:"category"`
	Content  string   `json:"content"`
	Labels   []string `json:"labels"`
	Severity string   `json:"severity"`
	Subject  string   `json:"subject"`
}

// NewProject defines model for NewProject.
type NewProject struct {
	Description *string  `json:"description,omitempty"`
	Labels      []string `json:"labels"`
	Name        string   `json:"name"`
}

// Project defines model for Project.
type Project struct {
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          string    `json:"id"`
	Labels      []string  `json:"labels"`
	Name        string    `json:"name"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// ProjectsPage defines model for ProjectsPage.
type ProjectsPage struct {
	Projects []Project `json:"projects"`
}

// UpdatedComment defines model for UpdatedComment.
type UpdatedComment struct {
	// Embedded struct due to allOf(#/components/schemas/NewComment)
	NewComment
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// UpdatedCustomer defines model for UpdatedCustomer.
type UpdatedCustomer struct {
	// Embedded struct due to allOf(#/components/schemas/NewCustomer)
	NewCustomer
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// UpdatedIssue defines model for UpdatedIssue.
type UpdatedIssue struct {
	// Embedded struct due to allOf(#/components/schemas/NewIssue)
	NewIssue
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// UpdatedProject defines model for UpdatedProject.
type UpdatedProject struct {
	// Embedded struct due to allOf(#/components/schemas/NewProject)
	NewProject
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// User defines model for User.
type User struct {
	CreatedAt time.Time `json:"created_at"`
	Email     string    `json:"email"`
	Id        string    `json:"id"`
	Name      string    `json:"name"`
	UpdatedAt time.Time `json:"updated_at"`
}

// UsersPage defines model for UsersPage.
type UsersPage struct {
	Users []User `json:"users"`
}

// FilterIssues defines model for filterIssues.
type FilterIssues []string

// Limit defines model for limit.
type Limit int64

// Offset defines model for offset.
type Offset int64

// Q defines model for q.
type Q string

// CustomersParams defines parameters for Customers.
type CustomersParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// ProjectsParams defines parameters for Projects.
type ProjectsParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// IssuesParams defines parameters for Issues.
type IssuesParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// CommentsParams defines parameters for Comments.
type CommentsParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// UsersParams defines parameters for Users.
type UsersParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// NewCustomerRequestBody defines body for NewCustomer for application/json ContentType.
type NewCustomerJSONRequestBody NewCustomer

// UpdateCustomerRequestBody defines body for UpdateCustomer for application/json ContentType.
type UpdateCustomerJSONRequestBody UpdatedCustomer

// NewProjectRequestBody defines body for NewProject for application/json ContentType.
type NewProjectJSONRequestBody NewProject

// UpdateProjectRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody UpdatedProject

// NewIssueRequestBody defines body for NewIssue for application/json ContentType.
type NewIssueJSONRequestBody NewIssue

// NewCommentRequestBody defines body for NewComment for application/json ContentType.
type NewCommentJSONRequestBody NewComment

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get a list of customers.// (GET /customers)
	Customers(ctx echo.Context, params CustomersParams) error
	// Create a customer.// (POST /customers)
	NewCustomer(ctx echo.Context) error
	// (GET /customers/{id})
	GetCustomer(ctx echo.Context, id string) error
	// Update a customer.// (PUT /customers/{id})
	UpdateCustomer(ctx echo.Context, id string) error
	// Get a list of projects.// (GET /projects)
	Projects(ctx echo.Context, params ProjectsParams) error
	// Create a project.// (POST /projects)
	NewProject(ctx echo.Context) error
	// Get a project.// (GET /projects/{id})
	GetProject(ctx echo.Context, id string) error
	// Update a project.// (PUT /projects/{id})
	UpdateProject(ctx echo.Context, id string) error
	// Get a list of issues.// (GET /projects/{project_id}/issues)
	Issues(ctx echo.Context, projectId string, params IssuesParams) error
	// Create a issue.// (POST /projects/{project_id}/issues)
	NewIssue(ctx echo.Context, projectId string) error
	// (GET /projects/{project_id}/issues/{id})
	GetIssue(ctx echo.Context, projectId string, id string) error
	// (PUT /projects/{project_id}/issues/{id})
	UpdateIssue(ctx echo.Context, projectId string, id string) error
	// Get a list of Comments.// (GET /projects/{project_id}/issues/{issue_id}/comments)
	Comments(ctx echo.Context, projectId string, issueId string, params CommentsParams) error
	// Create a comment on a issue.// (POST /projects/{project_id}/issues/{issue_id}/comments)
	NewComment(ctx echo.Context, projectId string, issueId string) error
	// (PUT /projects/{project_id}/issues/{issue_id}/comments/{id})
	UpdateComment(ctx echo.Context, projectId string, issueId string, id string) error
	// Get a list of users.// (GET /users)
	Users(ctx echo.Context, params UsersParams) error
	// (GET /users/{id})
	GetUser(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Customers converts echo context to params.
func (w *ServerInterfaceWrapper) Customers(ctx echo.Context) error {
	var err error

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/customer.read", "exitus/customer.admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Customers(ctx, params)
	return err
}

// NewCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) NewCustomer(ctx echo.Context) error {
	var err error

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/customer.write", "exitus/customer.admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewCustomer(ctx)
	return err
}

// GetCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/customer.read", "exitus/customer.admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomer(ctx, id)
	return err
}

// UpdateCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCustomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/customer.write", "customers.admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateCustomer(ctx, id)
	return err
}

// Projects converts echo context to params.
func (w *ServerInterfaceWrapper) Projects(ctx echo.Context) error {
	var err error

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/project.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProjectsParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Projects(ctx, params)
	return err
}

// NewProject converts echo context to params.
func (w *ServerInterfaceWrapper) NewProject(ctx echo.Context) error {
	var err error

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/project.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewProject(ctx)
	return err
}

// GetProject converts echo context to params.
func (w *ServerInterfaceWrapper) GetProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/project.read"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProject(ctx, id)
	return err
}

// UpdateProject converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/project.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateProject(ctx, id)
	return err
}

// Issues converts echo context to params.
func (w *ServerInterfaceWrapper) Issues(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/issue.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params IssuesParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Issues(ctx, projectId, params)
	return err
}

// NewIssue converts echo context to params.
func (w *ServerInterfaceWrapper) NewIssue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/issue.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewIssue(ctx, projectId)
	return err
}

// GetIssue converts echo context to params.
func (w *ServerInterfaceWrapper) GetIssue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/issue.read"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetIssue(ctx, projectId, id)
	return err
}

// UpdateIssue converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateIssue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/issue.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateIssue(ctx, projectId, id)
	return err
}

// Comments converts echo context to params.
func (w *ServerInterfaceWrapper) Comments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameter("simple", false, "issue_id", ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/comment.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CommentsParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Comments(ctx, projectId, issueId, params)
	return err
}

// NewComment converts echo context to params.
func (w *ServerInterfaceWrapper) NewComment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameter("simple", false, "issue_id", ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/comment.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewComment(ctx, projectId, issueId)
	return err
}

// UpdateComment converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateComment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameter("simple", false, "issue_id", ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/comment.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateComment(ctx, projectId, issueId, id)
	return err
}

// Users converts echo context to params.
func (w *ServerInterfaceWrapper) Users(ctx echo.Context) error {
	var err error

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/user.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UsersParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Users(ctx, params)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/user.read"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUser(ctx, id)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {
	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/customers", wrapper.Customers)
	router.POST("/customers", wrapper.NewCustomer)
	router.GET("/customers/:id", wrapper.GetCustomer)
	router.PUT("/customers/:id", wrapper.UpdateCustomer)
	router.GET("/projects", wrapper.Projects)
	router.POST("/projects", wrapper.NewProject)
	router.GET("/projects/:id", wrapper.GetProject)
	router.PUT("/projects/:id", wrapper.UpdateProject)
	router.GET("/projects/:project_id/issues", wrapper.Issues)
	router.POST("/projects/:project_id/issues", wrapper.NewIssue)
	router.GET("/projects/:project_id/issues/:id", wrapper.GetIssue)
	router.PUT("/projects/:project_id/issues/:id", wrapper.UpdateIssue)
	router.GET("/projects/:project_id/issues/:issue_id/comments", wrapper.Comments)
	router.POST("/projects/:project_id/issues/:issue_id/comments", wrapper.NewComment)
	router.PUT("/projects/:project_id/issues/:issue_id/comments/:id", wrapper.UpdateComment)
	router.GET("/users", wrapper.Users)
	router.GET("/users/:id", wrapper.GetUser)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"ppCUsf7SxTSHN5eb/wQAAP//E1OWH7tIAAA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
