// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Comment defines model for Comment.
type Comment struct {
	Author    User      `json:"author"`
	Content   string    `json:"content"`
	CreatedAt time.Time `json:"created_at"`
	Id        string    `json:"id"`
	UpdatedAt time.Time `json:"updated_at"`
}

// CommentsPage defines model for CommentsPage.
type CommentsPage struct {
	Comments  *[]Comment `json:"comments,omitempty"`
	NextToken *string    `json:"nextToken,omitempty"`
}

// Issue defines model for Issue.
type Issue struct {
	Assignee  *User         `json:"assignee,omitempty"`
	Author    User          `json:"author"`
	Category  *string       `json:"category,omitempty"`
	Comments  *CommentsPage `json:"comments,omitempty"`
	Content   *string       `json:"content,omitempty"`
	CreatedAt time.Time     `json:"created_at"`
	Id        string        `json:"id"`
	Labels    *[]string     `json:"labels,omitempty"`
	Severity  *string       `json:"severity,omitempty"`
	Subject   string        `json:"subject"`
	UpdatedAt time.Time     `json:"updated_at"`
}

// IssuesPage defines model for IssuesPage.
type IssuesPage struct {
	Issues    *[]Issue `json:"issues,omitempty"`
	NextToken *string  `json:"nextToken,omitempty"`
}

// NewComment defines model for NewComment.
type NewComment struct {
	Content string `json:"content"`
}

// NewIssue defines model for NewIssue.
type NewIssue struct {
	Content *string   `json:"content,omitempty"`
	Labels  *[]string `json:"labels,omitempty"`
	Subject string    `json:"subject"`
}

// NewProject defines model for NewProject.
type NewProject struct {
	Description *string  `json:"description,omitempty"`
	Labels      []string `json:"labels"`
	Name        string   `json:"name"`
}

// Project defines model for Project.
type Project struct {
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          string    `json:"id"`
	Labels      []string  `json:"labels"`
	Name        string    `json:"name"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// ProjectsPage defines model for ProjectsPage.
type ProjectsPage struct {
	NextToken *string    `json:"nextToken,omitempty"`
	Projects  *[]Project `json:"projects,omitempty"`
}

// UpdatedProject defines model for UpdatedProject.
type UpdatedProject struct {
	// Embedded struct due to allOf(#/components/schemas/NewProject)
	NewProject
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// User defines model for User.
type User struct {
	CreatedAt time.Time `json:"created_at"`
	Email     string    `json:"email"`
	Id        string    `json:"id"`
	Name      string    `json:"name"`
	UpdatedAt time.Time `json:"updated_at"`
}

// UsersPage defines model for UsersPage.
type UsersPage struct {
	NextToken *string `json:"nextToken,omitempty"`
	Users     *[]User `json:"users,omitempty"`
}

// FilterIssues defines model for filterIssues.
type FilterIssues []string

// Limit defines model for limit.
type Limit int64

// NextToken defines model for nextToken.
type NextToken string

// ProjectsParams defines parameters for Projects.
type ProjectsParams struct {
	NextToken *NextToken `json:"nextToken,omitempty"`
	Limit     *Limit     `json:"limit,omitempty"`
}

// IssuesParams defines parameters for Issues.
type IssuesParams struct {
	NextToken *NextToken    `json:"nextToken,omitempty"`
	Limit     *Limit        `json:"limit,omitempty"`
	Filter    *FilterIssues `json:"filter,omitempty"`
}

// CommentsParams defines parameters for Comments.
type CommentsParams struct {
	NextToken *NextToken `json:"nextToken,omitempty"`
	Limit     *Limit     `json:"limit,omitempty"`
}

// UsersParams defines parameters for Users.
type UsersParams struct {
	NextToken *NextToken `json:"nextToken,omitempty"`
	Limit     *Limit     `json:"limit,omitempty"`
}

// NewProjectRequestBody defines body for NewProject for application/json ContentType.
type NewProjectJSONRequestBody NewProject

// UpdateProjectRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody UpdatedProject

// NewIssueRequestBody defines body for NewIssue for application/json ContentType.
type NewIssueJSONRequestBody NewIssue

// NewCommentRequestBody defines body for NewComment for application/json ContentType.
type NewCommentJSONRequestBody NewComment

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get a list of projects.// (GET /projects)
	Projects(ctx echo.Context, params ProjectsParams) error
	// Create a project.// (POST /projects)
	NewProject(ctx echo.Context) error
	// (GET /projects/{id})
	GetProject(ctx echo.Context, id string) error
	// Update a project.// (PUT /projects/{id})
	UpdateProject(ctx echo.Context, id string) error
	// Get a list of issues.// (GET /projects/{project_id}/issues)
	Issues(ctx echo.Context, projectId string, params IssuesParams) error
	// Create a issue.// (POST /projects/{project_id}/issues)
	NewIssue(ctx echo.Context, projectId string) error
	// (GET /projects/{project_id}/issues/{id})
	GetIssue(ctx echo.Context, projectId string, id string) error
	// Get a list of Comments.// (GET /projects/{project_id}/issues/{issue_id}/comments)
	Comments(ctx echo.Context, projectId string, issueId string, params CommentsParams) error
	// Create a comment on a issue.// (POST /projects/{project_id}/issues/{issue_id}/comments)
	NewComment(ctx echo.Context, projectId string, issueId string) error
	// (GET /projects/{project_id}/issues/{issue_id}/comments/{id})
	GetComment(ctx echo.Context, projectId string, issueId string, id string) error
	// Get a list of users.// (GET /users)
	Users(ctx echo.Context, params UsersParams) error
	// (GET /users/{id})
	GetUser(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Projects converts echo context to params.
func (w *ServerInterfaceWrapper) Projects(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ProjectsParams
	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := ctx.QueryParam("nextToken"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Projects(ctx, params)
	return err
}

// NewProject converts echo context to params.
func (w *ServerInterfaceWrapper) NewProject(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewProject(ctx)
	return err
}

// GetProject converts echo context to params.
func (w *ServerInterfaceWrapper) GetProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProject(ctx, id)
	return err
}

// UpdateProject converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateProject(ctx, id)
	return err
}

// Issues converts echo context to params.
func (w *ServerInterfaceWrapper) Issues(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params IssuesParams
	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := ctx.QueryParam("nextToken"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "filter" -------------
	if paramValue := ctx.QueryParam("filter"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("pipeDelimited", true, false, "filter", ctx.QueryParams(), &params.Filter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter filter: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Issues(ctx, projectId, params)
	return err
}

// NewIssue converts echo context to params.
func (w *ServerInterfaceWrapper) NewIssue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewIssue(ctx, projectId)
	return err
}

// GetIssue converts echo context to params.
func (w *ServerInterfaceWrapper) GetIssue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetIssue(ctx, projectId, id)
	return err
}

// Comments converts echo context to params.
func (w *ServerInterfaceWrapper) Comments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameter("simple", false, "issue_id", ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params CommentsParams
	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := ctx.QueryParam("nextToken"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Comments(ctx, projectId, issueId, params)
	return err
}

// NewComment converts echo context to params.
func (w *ServerInterfaceWrapper) NewComment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameter("simple", false, "issue_id", ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewComment(ctx, projectId, issueId)
	return err
}

// GetComment converts echo context to params.
func (w *ServerInterfaceWrapper) GetComment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameter("simple", false, "issue_id", ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetComment(ctx, projectId, issueId, id)
	return err
}

// Users converts echo context to params.
func (w *ServerInterfaceWrapper) Users(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params UsersParams
	// ------------- Optional query parameter "nextToken" -------------
	if paramValue := ctx.QueryParam("nextToken"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Users(ctx, params)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUser(ctx, id)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {
	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/projects", wrapper.Projects)
	router.POST("/projects", wrapper.NewProject)
	router.GET("/projects/:id", wrapper.GetProject)
	router.PUT("/projects/:id", wrapper.UpdateProject)
	router.GET("/projects/:project_id/issues", wrapper.Issues)
	router.POST("/projects/:project_id/issues", wrapper.NewIssue)
	router.GET("/projects/:project_id/issues/:id", wrapper.GetIssue)
	router.GET("/projects/:project_id/issues/:issue_id/comments", wrapper.Comments)
	router.POST("/projects/:project_id/issues/:issue_id/comments", wrapper.NewComment)
	router.GET("/projects/:project_id/issues/:issue_id/comments/:id", wrapper.GetComment)
	router.GET("/users", wrapper.Users)
	router.GET("/users/:id", wrapper.GetUser)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"q78DAAD//5vycDrSLAAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
