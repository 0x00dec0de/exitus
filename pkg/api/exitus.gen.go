// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// Comment defines model for Comment.
type Comment struct {
	Author    User      `json:"author"`
	Content   string    `json:"content"`
	CreatedAt time.Time `json:"created_at"`
	Id        string    `json:"id"`
	UpdatedAt time.Time `json:"updated_at"`
}

// CommentsPage defines model for CommentsPage.
type CommentsPage struct {
	Comments []Comment `json:"comments"`
}

// Customer defines model for Customer.
type Customer struct {
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          string    `json:"id"`
	Labels      []string  `json:"labels"`
	Name        string    `json:"name"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// CustomersPage defines model for CustomersPage.
type CustomersPage struct {
	Customers []Customer `json:"customers"`
}

// Issue defines model for Issue.
type Issue struct {
	Assignee  *User         `json:"assignee,omitempty"`
	Category  string        `json:"category"`
	Comments  *CommentsPage `json:"comments,omitempty"`
	Content   *string       `json:"content,omitempty"`
	CreatedAt time.Time     `json:"created_at"`
	Id        string        `json:"id"`
	Labels    []string      `json:"labels"`
	Reporter  *User         `json:"reporter,omitempty"`
	Severity  string        `json:"severity"`
	State     string        `json:"state"`
	Subject   string        `json:"subject"`
	UpdatedAt time.Time     `json:"updated_at"`
}

// IssuesPage defines model for IssuesPage.
type IssuesPage struct {
	Issues []Issue `json:"issues"`
}

// NewComment defines model for NewComment.
type NewComment struct {
	Content string `json:"content"`
}

// NewCustomer defines model for NewCustomer.
type NewCustomer struct {
	Description *string  `json:"description,omitempty"`
	Labels      []string `json:"labels"`
	Name        string   `json:"name"`
}

// NewIssue defines model for NewIssue.
type NewIssue struct {
	Category string   `json:"category"`
	Content  string   `json:"content"`
	Labels   []string `json:"labels"`
	Severity string   `json:"severity"`
	Subject  string   `json:"subject"`
}

// NewProject defines model for NewProject.
type NewProject struct {
	Description *string  `json:"description,omitempty"`
	Labels      []string `json:"labels"`
	Name        string   `json:"name"`
}

// Project defines model for Project.
type Project struct {
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          string    `json:"id"`
	Labels      []string  `json:"labels"`
	Name        string    `json:"name"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// ProjectsPage defines model for ProjectsPage.
type ProjectsPage struct {
	Projects []Project `json:"projects"`
}

// UpdatedComment defines model for UpdatedComment.
type UpdatedComment struct {
	// Embedded struct due to allOf(#/components/schemas/NewComment)
	NewComment
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// UpdatedCustomer defines model for UpdatedCustomer.
type UpdatedCustomer struct {
	// Embedded struct due to allOf(#/components/schemas/NewCustomer)
	NewCustomer
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// UpdatedIssue defines model for UpdatedIssue.
type UpdatedIssue struct {
	// Embedded struct due to allOf(#/components/schemas/NewIssue)
	NewIssue
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// UpdatedProject defines model for UpdatedProject.
type UpdatedProject struct {
	// Embedded struct due to allOf(#/components/schemas/NewProject)
	NewProject
	// Embedded fields due to inline allOf schema
	Version int64 `json:"version"`
}

// User defines model for User.
type User struct {
	CreatedAt time.Time `json:"created_at"`
	Email     string    `json:"email"`
	Id        string    `json:"id"`
	Name      string    `json:"name"`
	UpdatedAt time.Time `json:"updated_at"`
}

// UsersPage defines model for UsersPage.
type UsersPage struct {
	Users []User `json:"users"`
}

// FilterIssues defines model for filterIssues.
type FilterIssues []string

// Limit defines model for limit.
type Limit int64

// Offset defines model for offset.
type Offset int64

// Q defines model for q.
type Q string

// CustomersParams defines parameters for Customers.
type CustomersParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// ProjectsParams defines parameters for Projects.
type ProjectsParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// IssuesParams defines parameters for Issues.
type IssuesParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// CommentsParams defines parameters for Comments.
type CommentsParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// UsersParams defines parameters for Users.
type UsersParams struct {
	Q      *Q      `json:"q,omitempty"`
	Offset *Offset `json:"offset,omitempty"`
	Limit  *Limit  `json:"limit,omitempty"`
}

// NewCustomerRequestBody defines body for NewCustomer for application/json ContentType.
type NewCustomerJSONRequestBody NewCustomer

// UpdateCustomerRequestBody defines body for UpdateCustomer for application/json ContentType.
type UpdateCustomerJSONRequestBody UpdatedCustomer

// NewProjectRequestBody defines body for NewProject for application/json ContentType.
type NewProjectJSONRequestBody NewProject

// UpdateProjectRequestBody defines body for UpdateProject for application/json ContentType.
type UpdateProjectJSONRequestBody UpdatedProject

// NewIssueRequestBody defines body for NewIssue for application/json ContentType.
type NewIssueJSONRequestBody NewIssue

// NewCommentRequestBody defines body for NewComment for application/json ContentType.
type NewCommentJSONRequestBody NewComment

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(req *http.Request, ctx context.Context) error

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// HTTP client with any customized settings, such as certificate chains.
	Client http.Client

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// The interface specification for the client above.
type ClientInterface interface {
	// Customers request
	Customers(ctx context.Context, params *CustomersParams) (*http.Response, error)

	// NewCustomer request  with any body
	NewCustomerWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	NewCustomer(ctx context.Context, body NewCustomer) (*http.Response, error)

	// GetCustomer request
	GetCustomer(ctx context.Context, id string) (*http.Response, error)

	// UpdateCustomer request  with any body
	UpdateCustomerWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	UpdateCustomer(ctx context.Context, id string, body UpdatedCustomer) (*http.Response, error)

	// Projects request
	Projects(ctx context.Context, params *ProjectsParams) (*http.Response, error)

	// NewProject request  with any body
	NewProjectWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	NewProject(ctx context.Context, body NewProject) (*http.Response, error)

	// GetProject request
	GetProject(ctx context.Context, id string) (*http.Response, error)

	// UpdateProject request  with any body
	UpdateProjectWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error)

	UpdateProject(ctx context.Context, id string, body UpdatedProject) (*http.Response, error)

	// Issues request
	Issues(ctx context.Context, projectId string, params *IssuesParams) (*http.Response, error)

	// NewIssue request  with any body
	NewIssueWithBody(ctx context.Context, projectId string, contentType string, body io.Reader) (*http.Response, error)

	NewIssue(ctx context.Context, projectId string, body NewIssue) (*http.Response, error)

	// GetIssue request
	GetIssue(ctx context.Context, projectId string, id string) (*http.Response, error)

	// UpdateIssue request
	UpdateIssue(ctx context.Context, projectId string, id string) (*http.Response, error)

	// Comments request
	Comments(ctx context.Context, projectId string, issueId string, params *CommentsParams) (*http.Response, error)

	// NewComment request  with any body
	NewCommentWithBody(ctx context.Context, projectId string, issueId string, contentType string, body io.Reader) (*http.Response, error)

	NewComment(ctx context.Context, projectId string, issueId string, body NewComment) (*http.Response, error)

	// UpdateComment request
	UpdateComment(ctx context.Context, projectId string, issueId string, id string) (*http.Response, error)

	// Users request
	Users(ctx context.Context, params *UsersParams) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, id string) (*http.Response, error)
}

func (c *Client) Customers(ctx context.Context, params *CustomersParams) (*http.Response, error) {
	req, err := NewCustomersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) NewCustomerWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewNewCustomerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) NewCustomer(ctx context.Context, body NewCustomer) (*http.Response, error) {
	req, err := NewNewCustomerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomer(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewGetCustomerRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomerWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateCustomerRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomer(ctx context.Context, id string, body UpdatedCustomer) (*http.Response, error) {
	req, err := NewUpdateCustomerRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) Projects(ctx context.Context, params *ProjectsParams) (*http.Response, error) {
	req, err := NewProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) NewProjectWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewNewProjectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) NewProject(ctx context.Context, body NewProject) (*http.Response, error) {
	req, err := NewNewProjectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetProject(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewGetProjectRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProjectWithBody(ctx context.Context, id string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateProjectRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateProject(ctx context.Context, id string, body UpdatedProject) (*http.Response, error) {
	req, err := NewUpdateProjectRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) Issues(ctx context.Context, projectId string, params *IssuesParams) (*http.Response, error) {
	req, err := NewIssuesRequest(c.Server, projectId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) NewIssueWithBody(ctx context.Context, projectId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewNewIssueRequestWithBody(c.Server, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) NewIssue(ctx context.Context, projectId string, body NewIssue) (*http.Response, error) {
	req, err := NewNewIssueRequest(c.Server, projectId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetIssue(ctx context.Context, projectId string, id string) (*http.Response, error) {
	req, err := NewGetIssueRequest(c.Server, projectId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIssue(ctx context.Context, projectId string, id string) (*http.Response, error) {
	req, err := NewUpdateIssueRequest(c.Server, projectId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) Comments(ctx context.Context, projectId string, issueId string, params *CommentsParams) (*http.Response, error) {
	req, err := NewCommentsRequest(c.Server, projectId, issueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) NewCommentWithBody(ctx context.Context, projectId string, issueId string, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewNewCommentRequestWithBody(c.Server, projectId, issueId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) NewComment(ctx context.Context, projectId string, issueId string, body NewComment) (*http.Response, error) {
	req, err := NewNewCommentRequest(c.Server, projectId, issueId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateComment(ctx context.Context, projectId string, issueId string, id string) (*http.Response, error) {
	req, err := NewUpdateCommentRequest(c.Server, projectId, issueId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) Users(ctx context.Context, params *UsersParams) (*http.Response, error) {
	req, err := NewUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, id string) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(req, ctx)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewCustomersRequest generates requests for Customers
func NewCustomersRequest(server string, params *CustomersParams) (*http.Request, error) {
	var err error

	queryUrl := fmt.Sprintf("%s/customers", server)

	var queryStrings []string

	var queryParam0 string
	if params.Q != nil {

		queryParam0, err = runtime.StyleParam("form", true, "q", *params.Q)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam0)
	}

	var queryParam1 string
	if params.Offset != nil {

		queryParam1, err = runtime.StyleParam("form", true, "offset", *params.Offset)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam1)
	}

	var queryParam2 string
	if params.Limit != nil {

		queryParam2, err = runtime.StyleParam("form", true, "limit", *params.Limit)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam2)
	}

	if len(queryStrings) != 0 {
		queryUrl += "?" + strings.Join(queryStrings, "&")
	}

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewCustomerRequest calls the generic NewCustomer builder with application/json body
func NewNewCustomerRequest(server string, body NewCustomer) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewCustomerRequestWithBody(server, "application/json", bodyReader)
}

// NewNewCustomerRequestWithBody generates requests for NewCustomer with any type of body
func NewNewCustomerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl := fmt.Sprintf("%s/customers", server)

	req, err := http.NewRequest("POST", queryUrl, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetCustomerRequest generates requests for GetCustomer
func NewGetCustomerRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/customers/%s", server, pathParam0)

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomerRequest calls the generic UpdateCustomer builder with application/json body
func NewUpdateCustomerRequest(server string, id string, body UpdatedCustomer) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomerRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateCustomerRequestWithBody generates requests for UpdateCustomer with any type of body
func NewUpdateCustomerRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/customers/%s", server, pathParam0)

	req, err := http.NewRequest("PUT", queryUrl, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewProjectsRequest generates requests for Projects
func NewProjectsRequest(server string, params *ProjectsParams) (*http.Request, error) {
	var err error

	queryUrl := fmt.Sprintf("%s/projects", server)

	var queryStrings []string

	var queryParam0 string
	if params.Q != nil {

		queryParam0, err = runtime.StyleParam("form", true, "q", *params.Q)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam0)
	}

	var queryParam1 string
	if params.Offset != nil {

		queryParam1, err = runtime.StyleParam("form", true, "offset", *params.Offset)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam1)
	}

	var queryParam2 string
	if params.Limit != nil {

		queryParam2, err = runtime.StyleParam("form", true, "limit", *params.Limit)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam2)
	}

	if len(queryStrings) != 0 {
		queryUrl += "?" + strings.Join(queryStrings, "&")
	}

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewProjectRequest calls the generic NewProject builder with application/json body
func NewNewProjectRequest(server string, body NewProject) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewProjectRequestWithBody(server, "application/json", bodyReader)
}

// NewNewProjectRequestWithBody generates requests for NewProject with any type of body
func NewNewProjectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl := fmt.Sprintf("%s/projects", server)

	req, err := http.NewRequest("POST", queryUrl, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetProjectRequest generates requests for GetProject
func NewGetProjectRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/projects/%s", server, pathParam0)

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateProjectRequest calls the generic UpdateProject builder with application/json body
func NewUpdateProjectRequest(server string, id string, body UpdatedProject) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateProjectRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateProjectRequestWithBody generates requests for UpdateProject with any type of body
func NewUpdateProjectRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/projects/%s", server, pathParam0)

	req, err := http.NewRequest("PUT", queryUrl, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewIssuesRequest generates requests for Issues
func NewIssuesRequest(server string, projectId string, params *IssuesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project_id", projectId)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/projects/%s/issues", server, pathParam0)

	var queryStrings []string

	var queryParam0 string
	if params.Q != nil {

		queryParam0, err = runtime.StyleParam("form", true, "q", *params.Q)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam0)
	}

	var queryParam1 string
	if params.Offset != nil {

		queryParam1, err = runtime.StyleParam("form", true, "offset", *params.Offset)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam1)
	}

	var queryParam2 string
	if params.Limit != nil {

		queryParam2, err = runtime.StyleParam("form", true, "limit", *params.Limit)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam2)
	}

	if len(queryStrings) != 0 {
		queryUrl += "?" + strings.Join(queryStrings, "&")
	}

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewIssueRequest calls the generic NewIssue builder with application/json body
func NewNewIssueRequest(server string, projectId string, body NewIssue) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewIssueRequestWithBody(server, projectId, "application/json", bodyReader)
}

// NewNewIssueRequestWithBody generates requests for NewIssue with any type of body
func NewNewIssueRequestWithBody(server string, projectId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project_id", projectId)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/projects/%s/issues", server, pathParam0)

	req, err := http.NewRequest("POST", queryUrl, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetIssueRequest generates requests for GetIssue
func NewGetIssueRequest(server string, projectId string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project_id", projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/projects/%s/issues/%s", server, pathParam0, pathParam1)

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIssueRequest generates requests for UpdateIssue
func NewUpdateIssueRequest(server string, projectId string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project_id", projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/projects/%s/issues/%s", server, pathParam0, pathParam1)

	req, err := http.NewRequest("PUT", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommentsRequest generates requests for Comments
func NewCommentsRequest(server string, projectId string, issueId string, params *CommentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project_id", projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "issue_id", issueId)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/projects/%s/issues/%s/comments", server, pathParam0, pathParam1)

	var queryStrings []string

	var queryParam0 string
	if params.Q != nil {

		queryParam0, err = runtime.StyleParam("form", true, "q", *params.Q)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam0)
	}

	var queryParam1 string
	if params.Offset != nil {

		queryParam1, err = runtime.StyleParam("form", true, "offset", *params.Offset)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam1)
	}

	var queryParam2 string
	if params.Limit != nil {

		queryParam2, err = runtime.StyleParam("form", true, "limit", *params.Limit)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam2)
	}

	if len(queryStrings) != 0 {
		queryUrl += "?" + strings.Join(queryStrings, "&")
	}

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewCommentRequest calls the generic NewComment builder with application/json body
func NewNewCommentRequest(server string, projectId string, issueId string, body NewComment) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewNewCommentRequestWithBody(server, projectId, issueId, "application/json", bodyReader)
}

// NewNewCommentRequestWithBody generates requests for NewComment with any type of body
func NewNewCommentRequestWithBody(server string, projectId string, issueId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project_id", projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "issue_id", issueId)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/projects/%s/issues/%s/comments", server, pathParam0, pathParam1)

	req, err := http.NewRequest("POST", queryUrl, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewUpdateCommentRequest generates requests for UpdateComment
func NewUpdateCommentRequest(server string, projectId string, issueId string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "project_id", projectId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParam("simple", false, "issue_id", issueId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/projects/%s/issues/%s/comments/%s", server, pathParam0, pathParam1, pathParam2)

	req, err := http.NewRequest("PUT", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersRequest generates requests for Users
func NewUsersRequest(server string, params *UsersParams) (*http.Request, error) {
	var err error

	queryUrl := fmt.Sprintf("%s/users", server)

	var queryStrings []string

	var queryParam0 string
	if params.Q != nil {

		queryParam0, err = runtime.StyleParam("form", true, "q", *params.Q)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam0)
	}

	var queryParam1 string
	if params.Offset != nil {

		queryParam1, err = runtime.StyleParam("form", true, "offset", *params.Offset)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam1)
	}

	var queryParam2 string
	if params.Limit != nil {

		queryParam2, err = runtime.StyleParam("form", true, "limit", *params.Limit)
		if err != nil {
			return nil, err
		}

		queryStrings = append(queryStrings, queryParam2)
	}

	if len(queryStrings) != 0 {
		queryUrl += "?" + strings.Join(queryStrings, "&")
	}

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "id", id)
	if err != nil {
		return nil, err
	}

	queryUrl := fmt.Sprintf("%s/users/%s", server, pathParam0)

	req, err := http.NewRequest("GET", queryUrl, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses returns a ClientWithResponses with a default Client:
func NewClientWithResponses(server string) *ClientWithResponses {
	return &ClientWithResponses{
		ClientInterface: &Client{
			Client: http.Client{},
			Server: server,
		},
	}
}

// NewClientWithResponsesAndRequestEditorFunc takes in a RequestEditorFn callback function and returns a ClientWithResponses with a default Client:
func NewClientWithResponsesAndRequestEditorFunc(server string, reqEditorFn RequestEditorFn) *ClientWithResponses {
	return &ClientWithResponses{
		ClientInterface: &Client{
			Client:        http.Client{},
			Server:        server,
			RequestEditor: reqEditorFn,
		},
	}
}

type customersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomersPage
}

// Status returns HTTPResponse.Status
func (r customersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r customersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type newCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Customer
}

// Status returns HTTPResponse.Status
func (r newCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r newCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Customer
}

// Status returns HTTPResponse.Status
func (r getCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Customer
}

// Status returns HTTPResponse.Status
func (r updateCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type projectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectsPage
}

// Status returns HTTPResponse.Status
func (r projectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r projectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type newProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Project
}

// Status returns HTTPResponse.Status
func (r newProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r newProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
}

// Status returns HTTPResponse.Status
func (r getProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Project
}

// Status returns HTTPResponse.Status
func (r updateProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type issuesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IssuesPage
}

// Status returns HTTPResponse.Status
func (r issuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r issuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type newIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Issue
}

// Status returns HTTPResponse.Status
func (r newIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r newIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Issue
}

// Status returns HTTPResponse.Status
func (r getIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateIssueResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdatedIssue
}

// Status returns HTTPResponse.Status
func (r updateIssueResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateIssueResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type commentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]CommentsPage
}

// Status returns HTTPResponse.Status
func (r commentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r commentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type newCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Comment
}

// Status returns HTTPResponse.Status
func (r newCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r newCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type updateCommentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdatedComment
}

// Status returns HTTPResponse.Status
func (r updateCommentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r updateCommentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type usersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersPage
}

// Status returns HTTPResponse.Status
func (r usersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r usersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type getUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
}

// Status returns HTTPResponse.Status
func (r getUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r getUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CustomersWithResponse request returning *CustomersResponse
func (c *ClientWithResponses) CustomersWithResponse(ctx context.Context, params *CustomersParams) (*customersResponse, error) {
	rsp, err := c.Customers(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParsecustomersResponse(rsp)
}

// NewCustomerWithBodyWithResponse request with arbitrary body returning *NewCustomerResponse
func (c *ClientWithResponses) NewCustomerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*newCustomerResponse, error) {
	rsp, err := c.NewCustomerWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsenewCustomerResponse(rsp)
}

func (c *ClientWithResponses) NewCustomerWithResponse(ctx context.Context, body NewCustomer) (*newCustomerResponse, error) {
	rsp, err := c.NewCustomer(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParsenewCustomerResponse(rsp)
}

// GetCustomerWithResponse request returning *GetCustomerResponse
func (c *ClientWithResponses) GetCustomerWithResponse(ctx context.Context, id string) (*getCustomerResponse, error) {
	rsp, err := c.GetCustomer(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParsegetCustomerResponse(rsp)
}

// UpdateCustomerWithBodyWithResponse request with arbitrary body returning *UpdateCustomerResponse
func (c *ClientWithResponses) UpdateCustomerWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*updateCustomerResponse, error) {
	rsp, err := c.UpdateCustomerWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseupdateCustomerResponse(rsp)
}

func (c *ClientWithResponses) UpdateCustomerWithResponse(ctx context.Context, id string, body UpdatedCustomer) (*updateCustomerResponse, error) {
	rsp, err := c.UpdateCustomer(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseupdateCustomerResponse(rsp)
}

// ProjectsWithResponse request returning *ProjectsResponse
func (c *ClientWithResponses) ProjectsWithResponse(ctx context.Context, params *ProjectsParams) (*projectsResponse, error) {
	rsp, err := c.Projects(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseprojectsResponse(rsp)
}

// NewProjectWithBodyWithResponse request with arbitrary body returning *NewProjectResponse
func (c *ClientWithResponses) NewProjectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*newProjectResponse, error) {
	rsp, err := c.NewProjectWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsenewProjectResponse(rsp)
}

func (c *ClientWithResponses) NewProjectWithResponse(ctx context.Context, body NewProject) (*newProjectResponse, error) {
	rsp, err := c.NewProject(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParsenewProjectResponse(rsp)
}

// GetProjectWithResponse request returning *GetProjectResponse
func (c *ClientWithResponses) GetProjectWithResponse(ctx context.Context, id string) (*getProjectResponse, error) {
	rsp, err := c.GetProject(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParsegetProjectResponse(rsp)
}

// UpdateProjectWithBodyWithResponse request with arbitrary body returning *UpdateProjectResponse
func (c *ClientWithResponses) UpdateProjectWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader) (*updateProjectResponse, error) {
	rsp, err := c.UpdateProjectWithBody(ctx, id, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseupdateProjectResponse(rsp)
}

func (c *ClientWithResponses) UpdateProjectWithResponse(ctx context.Context, id string, body UpdatedProject) (*updateProjectResponse, error) {
	rsp, err := c.UpdateProject(ctx, id, body)
	if err != nil {
		return nil, err
	}
	return ParseupdateProjectResponse(rsp)
}

// IssuesWithResponse request returning *IssuesResponse
func (c *ClientWithResponses) IssuesWithResponse(ctx context.Context, projectId string, params *IssuesParams) (*issuesResponse, error) {
	rsp, err := c.Issues(ctx, projectId, params)
	if err != nil {
		return nil, err
	}
	return ParseissuesResponse(rsp)
}

// NewIssueWithBodyWithResponse request with arbitrary body returning *NewIssueResponse
func (c *ClientWithResponses) NewIssueWithBodyWithResponse(ctx context.Context, projectId string, contentType string, body io.Reader) (*newIssueResponse, error) {
	rsp, err := c.NewIssueWithBody(ctx, projectId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsenewIssueResponse(rsp)
}

func (c *ClientWithResponses) NewIssueWithResponse(ctx context.Context, projectId string, body NewIssue) (*newIssueResponse, error) {
	rsp, err := c.NewIssue(ctx, projectId, body)
	if err != nil {
		return nil, err
	}
	return ParsenewIssueResponse(rsp)
}

// GetIssueWithResponse request returning *GetIssueResponse
func (c *ClientWithResponses) GetIssueWithResponse(ctx context.Context, projectId string, id string) (*getIssueResponse, error) {
	rsp, err := c.GetIssue(ctx, projectId, id)
	if err != nil {
		return nil, err
	}
	return ParsegetIssueResponse(rsp)
}

// UpdateIssueWithResponse request returning *UpdateIssueResponse
func (c *ClientWithResponses) UpdateIssueWithResponse(ctx context.Context, projectId string, id string) (*updateIssueResponse, error) {
	rsp, err := c.UpdateIssue(ctx, projectId, id)
	if err != nil {
		return nil, err
	}
	return ParseupdateIssueResponse(rsp)
}

// CommentsWithResponse request returning *CommentsResponse
func (c *ClientWithResponses) CommentsWithResponse(ctx context.Context, projectId string, issueId string, params *CommentsParams) (*commentsResponse, error) {
	rsp, err := c.Comments(ctx, projectId, issueId, params)
	if err != nil {
		return nil, err
	}
	return ParsecommentsResponse(rsp)
}

// NewCommentWithBodyWithResponse request with arbitrary body returning *NewCommentResponse
func (c *ClientWithResponses) NewCommentWithBodyWithResponse(ctx context.Context, projectId string, issueId string, contentType string, body io.Reader) (*newCommentResponse, error) {
	rsp, err := c.NewCommentWithBody(ctx, projectId, issueId, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParsenewCommentResponse(rsp)
}

func (c *ClientWithResponses) NewCommentWithResponse(ctx context.Context, projectId string, issueId string, body NewComment) (*newCommentResponse, error) {
	rsp, err := c.NewComment(ctx, projectId, issueId, body)
	if err != nil {
		return nil, err
	}
	return ParsenewCommentResponse(rsp)
}

// UpdateCommentWithResponse request returning *UpdateCommentResponse
func (c *ClientWithResponses) UpdateCommentWithResponse(ctx context.Context, projectId string, issueId string, id string) (*updateCommentResponse, error) {
	rsp, err := c.UpdateComment(ctx, projectId, issueId, id)
	if err != nil {
		return nil, err
	}
	return ParseupdateCommentResponse(rsp)
}

// UsersWithResponse request returning *UsersResponse
func (c *ClientWithResponses) UsersWithResponse(ctx context.Context, params *UsersParams) (*usersResponse, error) {
	rsp, err := c.Users(ctx, params)
	if err != nil {
		return nil, err
	}
	return ParseusersResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, id string) (*getUserResponse, error) {
	rsp, err := c.GetUser(ctx, id)
	if err != nil {
		return nil, err
	}
	return ParsegetUserResponse(rsp)
}

// ParsecustomersResponse parses an HTTP response from a CustomersWithResponse call
func ParsecustomersResponse(rsp *http.Response) (*customersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &customersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &CustomersPage{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParsenewCustomerResponse parses an HTTP response from a NewCustomerWithResponse call
func ParsenewCustomerResponse(rsp *http.Response) (*newCustomerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &newCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		response.JSON201 = &Customer{}
		if err := json.Unmarshal(bodyBytes, response.JSON201); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParsegetCustomerResponse parses an HTTP response from a GetCustomerWithResponse call
func ParsegetCustomerResponse(rsp *http.Response) (*getCustomerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &Customer{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	case rsp.StatusCode == 404:
		break // No content-type
	}

	return response, nil
}

// ParseupdateCustomerResponse parses an HTTP response from a UpdateCustomerWithResponse call
func ParseupdateCustomerResponse(rsp *http.Response) (*updateCustomerResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		response.JSON201 = &Customer{}
		if err := json.Unmarshal(bodyBytes, response.JSON201); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParseprojectsResponse parses an HTTP response from a ProjectsWithResponse call
func ParseprojectsResponse(rsp *http.Response) (*projectsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &projectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &ProjectsPage{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParsenewProjectResponse parses an HTTP response from a NewProjectWithResponse call
func ParsenewProjectResponse(rsp *http.Response) (*newProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &newProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		response.JSON201 = &Project{}
		if err := json.Unmarshal(bodyBytes, response.JSON201); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParsegetProjectResponse parses an HTTP response from a GetProjectWithResponse call
func ParsegetProjectResponse(rsp *http.Response) (*getProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &Project{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParseupdateProjectResponse parses an HTTP response from a UpdateProjectWithResponse call
func ParseupdateProjectResponse(rsp *http.Response) (*updateProjectResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		response.JSON201 = &Project{}
		if err := json.Unmarshal(bodyBytes, response.JSON201); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParseissuesResponse parses an HTTP response from a IssuesWithResponse call
func ParseissuesResponse(rsp *http.Response) (*issuesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &issuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &IssuesPage{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParsenewIssueResponse parses an HTTP response from a NewIssueWithResponse call
func ParsenewIssueResponse(rsp *http.Response) (*newIssueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &newIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		response.JSON201 = &Issue{}
		if err := json.Unmarshal(bodyBytes, response.JSON201); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParsegetIssueResponse parses an HTTP response from a GetIssueWithResponse call
func ParsegetIssueResponse(rsp *http.Response) (*getIssueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &Issue{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParseupdateIssueResponse parses an HTTP response from a UpdateIssueWithResponse call
func ParseupdateIssueResponse(rsp *http.Response) (*updateIssueResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateIssueResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &UpdatedIssue{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParsecommentsResponse parses an HTTP response from a CommentsWithResponse call
func ParsecommentsResponse(rsp *http.Response) (*commentsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &commentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &[]CommentsPage{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParsenewCommentResponse parses an HTTP response from a NewCommentWithResponse call
func ParsenewCommentResponse(rsp *http.Response) (*newCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &newCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		response.JSON201 = &Comment{}
		if err := json.Unmarshal(bodyBytes, response.JSON201); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParseupdateCommentResponse parses an HTTP response from a UpdateCommentWithResponse call
func ParseupdateCommentResponse(rsp *http.Response) (*updateCommentResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &updateCommentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &UpdatedComment{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParseusersResponse parses an HTTP response from a UsersWithResponse call
func ParseusersResponse(rsp *http.Response) (*usersResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &usersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &UsersPage{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ParsegetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParsegetUserResponse(rsp *http.Response) (*getUserResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &getUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		response.JSON200 = &User{}
		if err := json.Unmarshal(bodyBytes, response.JSON200); err != nil {
			return nil, err
		}
	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get a list of customers.// (GET /customers)
	Customers(ctx echo.Context, params CustomersParams) error
	// Create a customer.// (POST /customers)
	NewCustomer(ctx echo.Context) error
	// (GET /customers/{id})
	GetCustomer(ctx echo.Context, id string) error
	// Update a customer.// (PUT /customers/{id})
	UpdateCustomer(ctx echo.Context, id string) error
	// Get a list of projects.// (GET /projects)
	Projects(ctx echo.Context, params ProjectsParams) error
	// Create a project.// (POST /projects)
	NewProject(ctx echo.Context) error
	// Get a project.// (GET /projects/{id})
	GetProject(ctx echo.Context, id string) error
	// Update a project.// (PUT /projects/{id})
	UpdateProject(ctx echo.Context, id string) error
	// Get a list of issues.// (GET /projects/{project_id}/issues)
	Issues(ctx echo.Context, projectId string, params IssuesParams) error
	// Create a issue.// (POST /projects/{project_id}/issues)
	NewIssue(ctx echo.Context, projectId string) error
	// (GET /projects/{project_id}/issues/{id})
	GetIssue(ctx echo.Context, projectId string, id string) error
	// (PUT /projects/{project_id}/issues/{id})
	UpdateIssue(ctx echo.Context, projectId string, id string) error
	// Get a list of Comments.// (GET /projects/{project_id}/issues/{issue_id}/comments)
	Comments(ctx echo.Context, projectId string, issueId string, params CommentsParams) error
	// Create a comment on a issue.// (POST /projects/{project_id}/issues/{issue_id}/comments)
	NewComment(ctx echo.Context, projectId string, issueId string) error
	// (PUT /projects/{project_id}/issues/{issue_id}/comments/{id})
	UpdateComment(ctx echo.Context, projectId string, issueId string, id string) error
	// Get a list of users.// (GET /users)
	Users(ctx echo.Context, params UsersParams) error
	// (GET /users/{id})
	GetUser(ctx echo.Context, id string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// Customers converts echo context to params.
func (w *ServerInterfaceWrapper) Customers(ctx echo.Context) error {
	var err error

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/customer.read", "exitus/customer.admin"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CustomersParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Customers(ctx, params)
	return err
}

// NewCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) NewCustomer(ctx echo.Context) error {
	var err error

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/customer.write", "exitus/customer.admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewCustomer(ctx)
	return err
}

// GetCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/customer.read", "exitus/customer.admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomer(ctx, id)
	return err
}

// UpdateCustomer converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCustomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/customer.write", "customers.admin"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateCustomer(ctx, id)
	return err
}

// Projects converts echo context to params.
func (w *ServerInterfaceWrapper) Projects(ctx echo.Context) error {
	var err error

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/project.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ProjectsParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Projects(ctx, params)
	return err
}

// NewProject converts echo context to params.
func (w *ServerInterfaceWrapper) NewProject(ctx echo.Context) error {
	var err error

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/project.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewProject(ctx)
	return err
}

// GetProject converts echo context to params.
func (w *ServerInterfaceWrapper) GetProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/project.read"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetProject(ctx, id)
	return err
}

// UpdateProject converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/project.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateProject(ctx, id)
	return err
}

// Issues converts echo context to params.
func (w *ServerInterfaceWrapper) Issues(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/issue.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params IssuesParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Issues(ctx, projectId, params)
	return err
}

// NewIssue converts echo context to params.
func (w *ServerInterfaceWrapper) NewIssue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/issue.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewIssue(ctx, projectId)
	return err
}

// GetIssue converts echo context to params.
func (w *ServerInterfaceWrapper) GetIssue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/issue.read"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetIssue(ctx, projectId, id)
	return err
}

// UpdateIssue converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateIssue(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/issue.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateIssue(ctx, projectId, id)
	return err
}

// Comments converts echo context to params.
func (w *ServerInterfaceWrapper) Comments(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameter("simple", false, "issue_id", ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/comment.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CommentsParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Comments(ctx, projectId, issueId, params)
	return err
}

// NewComment converts echo context to params.
func (w *ServerInterfaceWrapper) NewComment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameter("simple", false, "issue_id", ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/comment.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.NewComment(ctx, projectId, issueId)
	return err
}

// UpdateComment converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateComment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameter("simple", false, "project_id", ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	// ------------- Path parameter "issue_id" -------------
	var issueId string

	err = runtime.BindStyledParameter("simple", false, "issue_id", ctx.Param("issue_id"), &issueId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter issue_id: %s", err))
	}

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/comment.write"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateComment(ctx, projectId, issueId, id)
	return err
}

// Users converts echo context to params.
func (w *ServerInterfaceWrapper) Users(ctx echo.Context) error {
	var err error

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/user.read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UsersParams
	// ------------- Optional query parameter "q" -------------
	if paramValue := ctx.QueryParam("q"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "q", ctx.QueryParams(), &params.Q)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter q: %s", err))
	}

	// ------------- Optional query parameter "offset" -------------
	if paramValue := ctx.QueryParam("offset"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {
	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Users(ctx, params)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameter("simple", false, "id", ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// HasSecurity is set

	ctx.Set("OpenId.Scopes", []string{"exitus/user.read"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUser(ctx, id)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router runtime.EchoRouter, si ServerInterface) {
	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/customers", wrapper.Customers)
	router.POST("/customers", wrapper.NewCustomer)
	router.GET("/customers/:id", wrapper.GetCustomer)
	router.PUT("/customers/:id", wrapper.UpdateCustomer)
	router.GET("/projects", wrapper.Projects)
	router.POST("/projects", wrapper.NewProject)
	router.GET("/projects/:id", wrapper.GetProject)
	router.PUT("/projects/:id", wrapper.UpdateProject)
	router.GET("/projects/:project_id/issues", wrapper.Issues)
	router.POST("/projects/:project_id/issues", wrapper.NewIssue)
	router.GET("/projects/:project_id/issues/:id", wrapper.GetIssue)
	router.PUT("/projects/:project_id/issues/:id", wrapper.UpdateIssue)
	router.GET("/projects/:project_id/issues/:issue_id/comments", wrapper.Comments)
	router.POST("/projects/:project_id/issues/:issue_id/comments", wrapper.NewComment)
	router.PUT("/projects/:project_id/issues/:issue_id/comments/:id", wrapper.UpdateComment)
	router.GET("/users", wrapper.Users)
	router.GET("/users/:id", wrapper.GetUser)
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"bv4XAAD//9oLvwDBRwAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
